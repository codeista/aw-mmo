/**
 * Fight or Die - Main Game Client
 * 
 * Turn-based tactical combat game inspired by Advance Wars
 * Features:
 * - 5x5 grid with terrain effects
 * - Unit movement and combat
 * - Real-time multiplayer via SpacetimeDB
 * - Mock mode for local development
 */

import { SpacetimeService } from './services/spacetime';
import { GameBoard } from './components/GameBoard';
import { GameState, GameStatus, Position } from './types/game';

// SpacetimeDB types (will be generated by spacetime generate command)
interface Player {
  id: string;
  username: string;
  created_at: number;
}

interface Game {
  id: number;
  player1: string;
  player2: string | null;
  current_turn: string;
  status: string;
  winner: string | null;
  created_at: number;
}

interface Board {
  game_id: number;
  terrain_data: string;
}

interface Unit {
  id: number;
  game_id: number;
  owner: string;
  x: number;
  y: number;
  hp: number;
  movement_left: number;
  has_attacked: boolean;
}

/**
 * Main game client class - handles game logic and UI updates
 */
class GameClient {
  private spacetime: SpacetimeService;
  private gameBoard: GameBoard | null = null;
  private state: GameState = {
    currentGameId: null,
    selectedUnit: null,
    selectedTile: null,
    validMoves: [],
    validAttacks: [],
    isMyTurn: false
  };
  private myIdentity: string | null = null;

  constructor() {
    this.spacetime = new SpacetimeService();
    this.setupUI();
  }

  private setupUI() {
    const loginBtn = document.getElementById('login-btn');
    const usernameInput = document.getElementById('username') as HTMLInputElement;
    
    loginBtn?.addEventListener('click', () => {
      const username = usernameInput.value.trim();
      if (username) {
        this.login(username);
      }
    });

    usernameInput?.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') {
        const username = usernameInput.value.trim();
        if (username) {
          this.login(username);
        }
      }
    });
  }

  private async login(username: string) {
    try {
      await this.spacetime.connect();
      
      // Store identity
      this.myIdentity = (this.spacetime as any).connection.identity;
      
      // Create player
      await this.spacetime.reducers.create_player(username);
      
      // Show game screen
      document.getElementById('login-screen')!.style.display = 'none';
      document.getElementById('game-screen')!.style.display = 'block';
      
      // Initialize game board
      const boardElement = document.getElementById('board')!;
      this.gameBoard = new GameBoard(boardElement, (x, y) => this.onTileClick(x, y));
      
      // Setup game controls
      this.setupGameControls();
      
      // Setup subscriptions
      this.setupSubscriptions();
      
      this.updateStatus('Connected! Create or join a game.');
    } catch (error) {
      console.error('Failed to connect:', error);
      alert('Failed to connect to server. Make sure SpacetimeDB is running.');
    }
  }

  private setupGameControls() {
    const createBtn = document.getElementById('create-game-btn');
    const joinBtn = document.getElementById('join-game-btn');
    const endTurnBtn = document.getElementById('end-turn-btn');
    const clearBtn = document.getElementById('clear-data-btn');
    
    createBtn?.addEventListener('click', () => this.createGame());
    joinBtn?.addEventListener('click', () => this.promptJoinGame());
    endTurnBtn?.addEventListener('click', () => this.endTurn());
    clearBtn?.addEventListener('click', () => {
      if (confirm('Clear all game data? This will reset everything.')) {
        localStorage.removeItem('mock-data');
        // Don't clear session storage - each tab keeps its identity
        location.reload();
      }
    });
  }

  private setupSubscriptions() {
    // Subscribe to games
    this.spacetime.db.Game.onInsert((game) => {
      this.updateGamesList();
      if (game.player1 === this.myIdentity || game.player2 === this.myIdentity) {
        this.state.currentGameId = game.id;
        this.updateGameState();
      }
    });

    this.spacetime.db.Game.onUpdate((oldGame, newGame) => {
      this.updateGamesList();
      if (this.state.currentGameId === newGame.id) {
        this.updateGameState();
      }
    });

    // Subscribe to boards
    this.spacetime.db.Board.onInsert((board) => {
      if (board.game_id === this.state.currentGameId) {
        this.gameBoard?.updateTerrain(board.terrain_data);
      }
    });

    // Subscribe to units
    this.spacetime.db.Unit.onInsert(() => this.updateUnits());
    this.spacetime.db.Unit.onUpdate(() => this.updateUnits());

    // Initial data fetch
    this.updateGamesList();
  }

  private async createGame() {
    try {
      await this.spacetime.reducers.create_game();
      this.updateStatus('Game created! Waiting for opponent...');
    } catch (error) {
      console.error('Failed to create game:', error);
      this.updateStatus('Failed to create game');
    }
  }

  private promptJoinGame() {
    const gameId = prompt('Enter game ID:');
    if (gameId && !isNaN(Number(gameId))) {
      this.joinGame(Number(gameId));
    }
  }

  private async joinGame(gameId: number) {
    try {
      await this.spacetime.reducers.join_game(gameId);
      this.state.currentGameId = gameId;
      this.updateStatus('Joined game!');
    } catch (error) {
      console.error('Failed to join game:', error);
      this.updateStatus('Failed to join game');
    }
  }

  private async endTurn() {
    if (!this.state.currentGameId) return;
    
    try {
      await this.spacetime.reducers.end_turn(this.state.currentGameId);
      this.state.selectedUnit = null;
      this.state.selectedTile = null;
      this.state.validMoves = [];
      this.state.validAttacks = [];
      this.gameBoard?.clearSelection();
      this.updateStatus('Turn ended');
    } catch (error) {
      console.error('Failed to end turn:', error);
    }
  }

  /**
   * Handles board tile clicks - select units, move, or attack
   */
  private onTileClick(x: number, y: number) {
    if (!this.state.currentGameId || !this.state.isMyTurn) return;

    // Check if clicking on a unit
    const units: Unit[] = Array.from(this.spacetime.db.Unit.all());
    const clickedUnit = units.find(u => 
      u.game_id === this.state.currentGameId && 
      u.x === x && 
      u.y === y &&
      u.hp > 0
    );

    if (clickedUnit) {
      if (clickedUnit.owner === this.myIdentity) {
        // Select own unit
        this.selectUnit(clickedUnit);
      } else if (this.state.selectedUnit) {
        // Attack enemy unit
        const myUnit = units.find(u => u.id === this.state.selectedUnit);
        if (myUnit && this.isAdjacent(myUnit.x, myUnit.y, x, y)) {
          this.attackUnit(clickedUnit.id);
        }
      }
    } else if (this.state.selectedUnit) {
      // Move to empty tile
      const myUnit = units.find(u => u.id === this.state.selectedUnit);
      if (myUnit && this.canMoveTo(myUnit, x, y)) {
        this.moveUnit(x, y);
      }
    }
  }

  private selectUnit(unit: Unit) {
    this.state.selectedUnit = unit.id;
    this.state.selectedTile = { x: unit.x, y: unit.y };
    
    // Calculate valid moves
    this.state.validMoves = this.calculateValidMoves(unit);
    this.state.validAttacks = this.calculateValidAttacks(unit);
    
    // Update board display
    this.gameBoard?.selectTile(unit.x, unit.y);
    this.gameBoard?.showValidMoves(this.state.validMoves);
    this.gameBoard?.showValidAttacks(this.state.validAttacks);
    
    this.updateUnitInfo(unit);
  }

  /**
   * Calculate all valid movement tiles for a unit (Manhattan distance)
   */
  private calculateValidMoves(unit: Unit): Position[] {
    const moves: Position[] = [];
    const units: Unit[] = Array.from(this.spacetime.db.Unit.all());
    
    for (let y = 0; y < 5; y++) {
      for (let x = 0; x < 5; x++) {
        const distance = Math.abs(x - unit.x) + Math.abs(y - unit.y);
        if (distance <= unit.movement_left && distance > 0) {
          // Check if tile is not occupied
          const occupied = units.some(u => 
            u.game_id === this.state.currentGameId &&
            u.x === x && 
            u.y === y && 
            u.hp > 0
          );
          if (!occupied) {
            moves.push({ x, y });
          }
        }
      }
    }
    
    return moves;
  }

  /**
   * Calculate all valid attack targets (adjacent enemies only)
   */
  private calculateValidAttacks(unit: Unit): Position[] {
    const attacks: Position[] = [];
    const units: Unit[] = Array.from(this.spacetime.db.Unit.all());
    
    // Check adjacent tiles for enemies
    const adjacentPositions = [
      { x: unit.x - 1, y: unit.y },
      { x: unit.x + 1, y: unit.y },
      { x: unit.x, y: unit.y - 1 },
      { x: unit.x, y: unit.y + 1 }
    ];
    
    adjacentPositions.forEach(pos => {
      if (pos.x >= 0 && pos.x < 5 && pos.y >= 0 && pos.y < 5) {
        const enemy = units.find(u =>
          u.game_id === this.state.currentGameId &&
          u.x === pos.x &&
          u.y === pos.y &&
          u.hp > 0 &&
          u.owner !== this.myIdentity
        );
        if (enemy && !unit.has_attacked) {
          attacks.push(pos);
        }
      }
    });
    
    return attacks;
  }

  private canMoveTo(unit: Unit, x: number, y: number): boolean {
    return this.state.validMoves.some(move => move.x === x && move.y === y);
  }

  private isAdjacent(x1: number, y1: number, x2: number, y2: number): boolean {
    const dx = Math.abs(x1 - x2);
    const dy = Math.abs(y1 - y2);
    return (dx === 1 && dy === 0) || (dx === 0 && dy === 1);
  }

  private async moveUnit(x: number, y: number) {
    if (!this.state.currentGameId || !this.state.selectedUnit) return;
    
    try {
      await this.spacetime.reducers.move_unit(
        this.state.currentGameId,
        this.state.selectedUnit,
        x,
        y
      );
      
      // Re-select unit after move to update valid attacks
      const units: Unit[] = Array.from(this.spacetime.db.Unit.all());
      const unit = units.find(u => u.id === this.state.selectedUnit);
      if (unit) {
        this.selectUnit(unit);
      }
    } catch (error) {
      console.error('Failed to move unit:', error);
    }
  }

  private async attackUnit(targetId: number) {
    if (!this.state.currentGameId || !this.state.selectedUnit) return;
    
    try {
      await this.spacetime.reducers.attack_unit(
        this.state.currentGameId,
        this.state.selectedUnit,
        targetId
      );
      
      this.state.selectedUnit = null;
      this.gameBoard?.clearSelection();
    } catch (error) {
      console.error('Failed to attack:', error);
    }
  }

  /**
   * Updates game UI based on current game state
   */
  private updateGameState() {
    if (!this.state.currentGameId) return;
    
    const games: Game[] = Array.from(this.spacetime.db.Game.all());
    const game = games.find(g => g.id === this.state.currentGameId);
    
    if (!game) return;
    
    this.state.isMyTurn = game.current_turn === this.myIdentity;
    
    // Update UI
    const endTurnBtn = document.getElementById('end-turn-btn');
    if (endTurnBtn) {
      endTurnBtn.style.display = this.state.isMyTurn ? 'block' : 'none';
    }
    
    // Update status
    if (game.status === GameStatus.WaitingForPlayers) {
      this.updateStatus('Waiting for opponent to join...');
    } else if (game.status === GameStatus.InProgress) {
      this.updateStatus(this.state.isMyTurn ? 'Your turn!' : "Opponent's turn...");
    } else if (game.status === GameStatus.Finished) {
      const winner = game.winner === this.myIdentity ? 'You won!' : 'You lost!';
      this.updateStatus(`Game Over - ${winner}`);
    }
    
    // Update turn info
    const turnInfo = document.getElementById('turn-info');
    if (turnInfo && game.status === GameStatus.InProgress) {
      const players: Player[] = Array.from(this.spacetime.db.Player.all());
      const currentPlayer = players.find(p => p.id === game.current_turn);
      turnInfo.textContent = `Current turn: ${currentPlayer?.username || 'Unknown'}`;
    }
    
    this.updateUnits();
  }

  private updateUnits() {
    if (!this.state.currentGameId || !this.gameBoard) return;
    
    this.gameBoard.clearUnits();
    
    const units: Unit[] = Array.from(this.spacetime.db.Unit.all());
    const games: Game[] = Array.from(this.spacetime.db.Game.all());
    const game = games.find(g => g.id === this.state.currentGameId);
    
    if (!game) return;
    
    units
      .filter(u => u.game_id === this.state.currentGameId && u.hp > 0)
      .forEach(unit => {
        const isPlayer1 = unit.owner === game.player1;
        const playerId = isPlayer1 ? 'player1' : 'player2';
        const isCurrentTurn = unit.owner === game.current_turn;
        
        this.gameBoard!.addUnit(unit.x, unit.y, playerId, unit.hp, 100, isCurrentTurn);
      });
  }

  private updateGamesList() {
    const gamesList = document.getElementById('games-list');
    if (!gamesList) return;
    
    const games: Game[] = Array.from(this.spacetime.db.Game.all());
    const waitingGames = games.filter(g => g.status === GameStatus.WaitingForPlayers);
    
    if (waitingGames.length === 0) {
      gamesList.innerHTML = '<p>No games available</p>';
    } else {
      gamesList.innerHTML = waitingGames
        .map(g => {
          const isMyGame = g.player1 === this.myIdentity;
          return `
            <div>
              Game #${g.id} ${isMyGame ? '(Your game)' : ''} - 
              ${isMyGame ? 'Waiting for opponent...' : `<button onclick="window.gameClient.joinGame(${g.id})">Join</button>`}
            </div>
          `;
        })
        .join('');
    }
  }

  private updateStatus(message: string) {
    const statusEl = document.getElementById('status-message');
    if (statusEl) {
      statusEl.textContent = message;
    }
  }

  private updateUnitInfo(unit: Unit) {
    const unitInfo = document.getElementById('unit-info');
    if (unitInfo) {
      unitInfo.innerHTML = `
        <h4>Selected Unit</h4>
        <p>HP: ${unit.hp}/100</p>
        <p>Movement: ${unit.movement_left}/3</p>
        <p>Can Attack: ${unit.has_attacked ? 'No' : 'Yes'}</p>
      `;
    }
  }
}

// Create global instance
const gameClient = new GameClient();
(window as any).gameClient = gameClient;